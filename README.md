# jda-commands [![maven-central](https://img.shields.io/maven-central/v/com.github.romanqed/jda-commands?color=blue)](https://repo1.maven.org/maven2/com/github/romanqed/jda-commands/)

A small library that implements a command system for JDA. Uses jeflect.

## Getting Started

To install it, you will need:

* java 11+
* [classindex](https://github.com/atteo/classindex)
* Maven/Gradle

## Installing

### Gradle dependency

```Groovy
dependencies {
    annotationProcessor group: 'org.atteo.classindex', name: 'classindex', version: '3.11'
    implementation group: 'com.github.romanqed', name: 'jda-commands', version: 'LATEST'
}
```

### Maven dependency

```
<dependency>
    <groupId>com.github.romanqed</groupId>
    <artifactId>jda-commands</artifactId>
    <version>LATEST</version>
</dependency>
```

## Main features
- Fast class access instead of built-in reflect api with jeflect (generated bytecode proxies)
- Method parameters to command arguments mapping by default
- Complete freedom in binding the library to jda
- Guild and private commands
- Access checks (for permissions and roles)
- Help and Description annotations
- Custom codecs for command argument types
- Complete freedom in reusing various parts of the library

## Usage example

### Declare listener adapter

```Java
public class YourListenerAdapter extends JDAListenerAdapter {
    private static final GuildHandlerFactory GUILD_FACTORY = new GuildHandlerFactory();
    private static final PersonalHandlerFactory PERSONAL_FACTORY = new PersonalHandlerFactory();

    public YourListenerAdapter() {
        super(GUILD_FACTORY.create(), PERSONAL_FACTORY.create());
    }

    @Override
    protected String getPrefix(Message message) {
        // Process message and decide what prefix you want using
        // For example, get guildId and load prefix for it from your bot db
        // repository.get(message.getGuild.getIdLong()).getPrefix(); (or something else)
        return "!";
    }

    @Override
    protected void onCommandNotFound(Message message, String command) {
        // Do something if command not found
    }

    @Override
    protected void onIllegalCommandArguments(Message message, List<String> arguments) {
        // Do something if command received invalid arguments
    }

    @Override
    protected void onCommandAccessException(Message message, Member member, String command) {
        // Do something if somebody without required perms tried to access command
    }

    @Override
    protected void onException(Message message, Throwable e) {
        // Do something if exception was thrown
    }
}
```

### Declare your commands
```Java
@GuildCommand("your_command_name")
@GuildPermission({Permission.JDA_PERMISSION, Permission.JDA_PERMISSION1})
@GuildRole({"YourCommandRoleName", "YourCommandRoleName1"})
public class YourCommandClass {
    @CommandMethod
    public void yourCommandMethodName(Message message
            /*, your, command, arguments, @Optional your, @Optional optional, @Optional arguments*/
    ) {
        // Your command code
    }
}
```

Thus, the library allows you to create any commands that you need.

### Command arguments
In order to set command arguments, you need to define a specific set of method parameters, for example like this:
```Java
@GuildCommand("echo")
public class Echo {
    @CommandMethod
    public void execute(Message message, String text) {
        message.reply("You say: " + text).queue();
    }
}
```

When processing this command, the text argument will be considered mandatory and cannot be omitted.
That is, the following command call is valid: "echo hello,world", but such a call - "echo" - is not.

<p>The parser also supports parsing a string with quotes by default: "a "b c" d" will turn into [a, b c, d]</p>

<p>However, if you are not satisfied with the built-in tokenizer, you can easily use a custom one:</p>

```Java
public class YourListenerAdapter extends JDAListenerAdapter {
    private static final Tokenizer YOUR_TOKENIZER = new YourTokenizer();
    private static final GuildHandlerFactory GUILD_FACTORY = new GuildHandlerFactory();
    private static final PersonalHandlerFactory PERSONAL_FACTORY = new PersonalHandlerFactory();

    public YourListenerAdapter() {
        super(GUILD_FACTORY.create(YOUR_TOKENIZER), PERSONAL_FACTORY.create(YOUR_TOKENIZER));
    }

    ...
}

class YourTokenizer implements Tokenizer {
    @Override
    public List<String> tokenize(String string) {
        ...
        return tokens;
    }
}
```

### Codecs

If you need to use a custom type parameter that is not included in the standard codec set 
(char, double, float, int, long, string), you can define your argument type and codec for it yourself.

For example, codec for date:

```Java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.function.Function;

@Codec(Date.class)
public class DateCodec implements Function<String, Date> {
    private static final SimpleDateFormat FORMATTER = new SimpleDateFormat("yyyy-MM-dd");

    @Override

    public Date apply(String input) {
        try {
            return FORMATTER.parse(input);  
        } catch (ParseException e) {
            throw new IllegalArgumentException("Can't parse date due to", e);
        }
    }
}
```

And command using it:

```Java
import java.util.Date;

@GuildCommand("some_command")
public class SomeCommand {
    @CommandMethod
    public void execute(Message message, Date date) {
        // Do something
    }
}
```

### Implementation for help command
The library is not something closed, and you can easily modify the way commands will be received 
and/or processed by simply redefining the required factory.

However, the built-in factory implementations for Guild and Private handlers already provide basic functionality 
sufficient to implement the help command.

Using the GuildHandlerFactory#getCommands call, you can get the full set of found commands 
in the form of a Map and process them in the desired way.

The library also has built-in annotations to define the help and description fields for your command:

```Java
@Help("call [prefix]your_command arg1 arg2")
@Description("do something really important")
@GuildCommand("your_command")
public class YourCommandClass {
    ...
}
```

In general, the implementation of the help command may look like this:

```Java
import java.util.function.Function;

// Codec for GuildCommand
@Codec(GuildDiscordCommand.class)
public class GuildCommandCodec implements Function<String, GuildDiscordCommand> {
    @Override
    public GuildDiscordCommand apply(String command) {
        var found = GuildHandlerFactory.getCommands().get(command);
        if (found == null) {
            throw new CommandNotFoundException(command);
        }
        return found;
    }
}
```

```Java
// Command impl
@GuildCommand("help")
public class GuildHelp {
    @CommandMethod
    public void execute(Message message, GuildDiscordCommand command) {
        message.reply("Help: " + command.getHelp() + "\n" + "Description: " + command.getDescription() + "\n").queue();
    }
}
```


## Built With

* [Gradle](https://gradle.org) - Dependency management
* [classindex](https://github.com/atteo/classindex) - Annotation scanning
* [jeflect](https://github.com/RomanQed/jeflect) - Method wrapping
* [jda](https://github.com/DV8FromTheWorld/JDA) - Discord API

## Authors

* **RomanQed** - *Main work* - [RomanQed](https://github.com/RomanQed)

See also the list of [contributors](https://github.com/RomanQed/jda-commands/contributors) who participated
in this project.

## License

This project is licensed under the Apache License Version 2.0 - see the [LICENSE](LICENSE) file for details
